### bean的作用域

在默认情况下，Spring应用 上下文中所有bean都是作为以单例\(singleton\) 的形式创建的。

也就是说，不管给定的一个bean被注入到其他bean多少次，每次所注入的都是同一个实例。

* 单例\(Singleton\) :在整个应用中，只创建bean的一个实例。

* 原型\(Prototype\) :每次注入或者通过Spring应用上下文获取的时候，都会创建一个新

  的bean实例。

* 会话\(Session\):在Web应用中，为每个会话创建一个bean实例。

* 请求\(Rquest\) :在Web应用中，为每个请求创建一个bean实例。

### 面向切面编程 _AOP_为Aspect Oriented Programming

通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。

#### 通知（Advice）

切面的工作被称为通知

Spring切面有五种类型的通知：

* 前置通知\(Before\) :在目标方法被调用之前调用通知功能;

* 后置通知\(After\) :在目标方法完成之后调用通知，此时不会关心方法的输出是什么;

* 返回通知\( After-returning\) :在目标方法成功执行之后调用通知;

* 异常通知\(After-throwing\) :在目标方法抛出异常后调用通知;

* 环绕通知\(Around\):通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为。

### 连接点（Join point）

这些时机被称为连接点连接点是在应用执行过程中能够插入切面的一个点。这个点可以是调用方法时、抛出异常时、甚至修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。

### 切点（Poincut）

一个切面并不需要通知应用的所有  
连接点。切点有助于缩小切面所通知的连接点的范围。

如果说通知定义了切面的“什么”和“何时”的话，那么切点就定义了“何处”。切点的定义会匹  
配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称，或是利用正则表  
达式定义所匹配的类和方法名称来指定这些切点。有些AOP框架允许我们创建动态的切点，  
可以根据运行时的决策（比如方法的参数值）来决定是否应用通知。

### 切面（Aspect）

切面是通知和切点的结合。通知和切点共同定义了切面的全部内容——它是什么，在何时和  
何处完成其功能。

### 引入（Introduction）

引入允许我们向现有的类添加新方法或属性。例如，我们可以创建一个Auditable通知  
类，该类记录了对象最后一次修改时的状态。这很简单，只需一个方  
法，setLastModified\(Date\)，和一个实例变量来保存这个状态。然后，这个新方法和  
实例变量就可以被引入到现有的类中，从而可以在无需修改这些现有的类的情况下，让它们  
具有新的行为和状态。

## 织入（Weaving）

织入是把切面应用到目标对象并创建新的代理对象的过程。切面在指定的连接点被织入到目  
标对象中。在目标对象的生命周期里有多个点可以进行织入：

编译期：切面在目标类编译时被织入。这种方式需要特殊的编译器。AspectJ的织入编译  
器就是以这种方式织入切面的。

类加载期：切面在目标类加载到JVM时被织入。这种方式需要特殊的类加载器  
（ClassLoader），它可以在目标类被引入应用之前增强该目标类的字节码。AspectJ  
5的加载时织入（load-time weaving，LTW）就支持以这种方式织入切面。

运行期：切面在应用运行的某个时刻被织入。一般情况下，在织入切面时，AOP容器会  
为目标对象动态地创建一个代理对象。Spring AOP就是以这种方式织入切面的。

### Spring提供了4种类型的AOP支持：

* 基于代理的经典Spring AOP；

* 纯POJO切面；

* @AspectJ注解驱动的切面；

* 注入式AspectJ切面（适用于Spring各版本）。

#### Spring在运行时通知对象

通过在代理类中包裏切面，Spring在运行期把切面织入到Spring管理的bean中。代理类封装了目标类，并拦截被通知方法的调用，再把调用转发给真正的目标bean。当代理拦截到方法调用时，在调用目标bean方法之前，会执行切面逻辑。

Spring的切面 由包裹了目标对象的代理类实现。

代理类处理方法的调用，执行额外的切面逻辑，并调用目标方法

直到应用需要被代理的bean时，Spring才 创建代理对象。如果使用的是ApplicationContext的话，在ApplicationContext从BeanFactory中加载所有bean的时候，Spring才会创建被代理的对象。因为Spring运行时才创建代理对象，所以我们不需要特殊的编译器来织入SpringAOP的切面。





