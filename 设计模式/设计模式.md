## 接口隔离原则

类间的依赖关系应该建立在最小的接口上。

## 开闭原则

一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。

软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。

注意 开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。

开闭原则的重要性

1. 开闭原则对测试的影响

2. 开闭原则可以提高复用性

   所有的逻辑都是从原子逻辑组合而来的，而不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。那为什么要复用呢？减少代码量，避免相同的逻辑分散在多个角落

   那怎么才能提高复用率呢？缩小逻辑粒度，直到一个逻辑不可再拆分为止。

3. 开闭原则可以提高可维护性

4. 面向对象开发的要求

开闭原则的使用

1. 抽象约束

   抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：第一，通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；第二，参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；第三，抽象层尽量保持稳定，一旦确定即不允许修改。

2. 元数据（metadata）控制模块行为

   元数据用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。

3. 制定项目章程

4. 封装变化

   对变化的封装包含两层含义：第一，将相同的变化封装到一个接口或抽象类中；第二，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。封装变化，也就是受保护的变化（protected variations），找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，一旦预测到或“第六感”发觉有变化，就可以进行封装

注意事项

- 循这6大设计原则基本上可以应对大多数变化。因此，我们在项目中应尽量采用这6大原则，适当时候可以进行扩充

- 项目规章非常重要 

  优秀的章程能带给项目带来非常多的好处，如提高开发效率、降低缺陷率、提高团队士气、提高技术成员水平，等等。

- 预知变化

## 单例模式

确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。

```java
/**
 * 单例模式通用代码
 * 懒汉式
 */
public class Singleton {
    private static final Singleton singleton = new Singleton();

    // 限制产生多个对象
    private Singleton() {

    }

    // 通过该方法获取实例对象
    public static Singleton getSingleton() {
        return singleton;
    }

    // 类中其他方法，尽量是static
    public static void doSonmething() {
        
    }

}
```

```java
/**
 * 懒汉式单例
 */
public class Singleton {

    private static Singleton singleton = null;

    // 限制产生多个对象
    private Singleton() {

    }
    
    // 通过该方法获得实例对象
    public static synchronized Singleton getSingleton() {
        if (singleton == null)
            singleton = new Singleton();
        return singleton;
    }
}
```



### 单例模式的优点

由于单例模式在内存中只有一个实例，减少了内存开支，特别是一个对象需要频繁地创建、销毁时，而且创建或销毁时性能又无法优化，单例模式的优势就非常明显。

由于单例模式只生成一个实例，所以减少了系统的性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后用永久驻留内存的方式来解决（在Java EE中采用单例模式时需要注意JVM垃圾回收机制）。单例模式可以避免对资源的多重占用，例如一个写文件动作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作。

单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理。

### 单例模式的缺点

单例模式一般没有接口，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。单例模式为什么不能增加接口呢？因为接口对单例模式是没有任何意义的，它要求“自行实例化”，并且提供单一实例、接口或抽象类是不可能被实例化的。当然，在特殊情况下，单例模式可以实现接口、被继承等，需要在系统开发中根据环境判断。

单例模式对测试是不利的。在并行开发环境中，如果单例模式没有完成，是不能进行测试的，没有接口也不能使用mock的方式虚拟一个对象。

单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑，而不关心它是否是单例的，是不是要单例取决于环境，单例模式把“要单例”和业务逻辑融合在一个类中。

### 单例模式的使用场景

在一个系统中，要求一个类有且仅有一个对象，如果出现多个对象就会出现“不良反应”，可以采用单例模式，具体的场景如下：

- 要求生成唯一序列号的环境；
- 在整个项目中需要一个共享访问点或共享数据，例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；
- 创建一个对象需要消耗的资源过多，如要访问IO和数据库等资源；
- 需要定义大量的静态常量和静态方法（如工具类）的环境，可以采用单例模式（当然，也可以直接声明为static的方式）。

## 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

```java
package com.ycf.factory;

/**
 * 通用代码
 */
public abstract class Product {
    public void method1() {
    }

    public abstract void method2();
}

class ConcreteProduct1 extends Product {

    @Override
    public void method2() {
    }
}

class ConcreteProduct2 extends Product {

    @Override
    public void method2() {
    }

}

abstract class Creator {
    public abstract <T extends Product> T createProduct(Class<T> c);
}

class ConcreteCreator extends Creator {

    @Override
    @SuppressWarnings("unchecked")
    public <T extends Product> T createProduct(Class<T> c) {
        Product product = null;

        try {
            product = (Product) Class.forName(c.getName()).newInstance();
        } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
            e.printStackTrace();
        }
        return (T) product;
    }
    
}
```



### 工厂方法模式的优点

首先，良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。

其次，工厂方法模式的扩展性非常优秀。在增加产品类的情况下，只要适当地修改具体的工厂类或扩展一个工厂类，就可以完成“拥抱变化”。

再次，屏蔽产品类。这一特点非常重要，产品类的实现如何变化，调用者都不需要关心，它只需要关心产品的接口，只要接口保持不变，系统中的上层模块就不要发生变化。

最后，工厂方法模式是典型的解耦框架。高层模块值需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！

### 工厂方法模式的使用场景

首先，工厂方法模式是new一个对象的替代品，所以在所有需要生成对象的地方都可以使用，但是需要慎重地考虑是否要增加一个工厂类进行管理，增加代码的复杂度。

其次，需要灵活的、可扩展的框架时，可以考虑采用工厂方法模式。万物皆对象，那万物也就皆产品类。

再次，工厂方法模式可以用在异构项目中。

最后，可以使用在测试驱动开发的框架下。

### 工厂方法模式的扩展

#### 简单工厂模式

（Simple Factory Pattern），也叫做静态工厂模式。在实际项目中，采用该方法的案例还是比较多的，其缺点是工厂类的扩展比较困难，不符合开闭原则，但它仍然是一个非常实用的设计模式。

去掉继承抽象类，并在createHuman前增加static关键字；

#### 多工厂模式

抽象方法中已经不再需要传递相关参数了，因为每一个具体的工厂都已经非常明确自己的职责：创建自己负责的产品类对象。

好处就是创建类的职责清晰，而且结构简单，但是给可扩展性和可维护性带来了一定的影响。

#### 替代单例模式



```java
/**
 * 负责生成单例的工厂类
 * 通过获得类构造器，然后设置访问权限，生成一个对象，然后提供外部访问，保证内存中的对象唯一。
 */
public class SingletonFactory {
    private static Singleton singleton;

    static {
        try {
            Class cl = Class.forName(Singleton.class.getName());
            Constructor constructor = cl.getDeclaredConstructor();
            constructor.setAccessible(true);
            singleton = (Singleton) constructor.newInstance();

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public static Singleton getSingleton() {
        return singleton;
    }
}
```



#### 延迟初始化	

一个对象被消费完毕后，并不立刻释放，工厂类保持其初始状态，等待再次被使用。

```java
/**
 * 延迟加载的工厂类
 * 通过定义一个Map容器，容纳所有产生的对象，如果在Map容器中已经有的对象，则直接取出返回；如果没有，则根据需要	*	的类型产生一个对象并放入到Map容器中，以方便下次调用。
 */
public class ProductFactory {
    private static final Map<String, Product> prMap = new HashMap<>();

    public static synchronized Product createProduct(String type) {
        Product product = null;
        if (prMap.containsKey(type)) {
            prMap.get(type);
        } else {
            if (type.equals("product1")) {
                product = new ConcreteProduct1();
            } else {
                product = new ConcreteProduct2();
            }
            prMap.put(type, product);
        }
        return product;
    }
}
```

## 模板方法模式

定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

模板方法模式确实非常简单，仅仅使用了Java的继承机制，但它是一个应用非常广泛的模式。其中，AbstractClass叫做抽象模板，它的方法分为两类：

- 基本方法基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。
- 模板方法可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。

注意 为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。

```java
/**
 * 抽象模板类
 */
public abstract class AbstractClass {
    // 基本方法
    protected abstract void doSomething();

    // 基本方法
    protected abstract void doAnythiing();

    // 模版方法
    public void templateMethod() {
        doSomething();
        doAnythiing();
    }
}
```

```java
public class ConcreteClass1 extends AbstractClass {

    @Override
    protected void doSomething() {
        // 业务逻辑处理
    }

    @Override
    protected void doAnythiing() {
        // 业务逻辑处理
    }
}
```

```java
public class ConcreteClass2 extends AbstractClass {

    @Override
    protected void doSomething() {
        // 业务逻辑处理
    }

    @Override
    protected void doAnythiing() {
        // 业务逻辑处理
    }
}
```



### 模板方法模式的优点

- 封装不变部分，扩展可变部分

  把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展

- 提取公共部分代码，便于维护

- 行为由父类控制，子类实现

  基本方法是由子类实现的，因此子类可以通过扩展的方式增加相应的功能，符合开闭原则。

### 模板方法模式的缺点

按照我们的设计习惯，抽象类负责声明最抽象、最一般的事物属性和方法，实现类完成具体的事物属性和方法。但是模板方法模式却颠倒了，抽象类定义了部分抽象方法，由子类实现，子类执行的结果影响了父类的结果，也就是子类对父类产生了影响，这在复杂的项目中，会带来代码阅读的难度，而且也会让新手产生不适感。

### 模板方法模式的扩展

外界条件改变，影响到模板方法的执行。该方法就叫做钩子方法（HookMethod）。

模板方法模式就是在模板方法中按照一定的规则和顺序调用基本方法

## 建造者模式

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

在建造者模式中，有如下4个角色：

- Product产品类

  通常是实现了模板方法模式，也就是有模板方法和基本方法

- Builder抽象建造者

  规范产品的组建，一般是由子类实现。

- ConcreteBuilder具体建造者

  实现抽象类定义的所有方法，并且返回一个组建好的对象。

  需要注意的是，如果有多个产品类就有几个具体的建造者，而且这多个产品类具有相同接口或抽象类

- Director导演类

  负责安排已有模块的顺序，然后告诉Builder开始建造。

  导演类起到封装的作用，避免高层模块深入到建造者内部的实现类。当然，在建造者模式比较庞大时，导演类可以有多个。

```java
package com.ycf.designPattern.BuilderPattern;

/**
 * 通常它是一个组合或继承（如模板方法模式）产生的类
 */
public class Product {
    public void doSomething() {
        // 独立业务处理
    }
}
```

```java
package com.ycf.designPattern.BuilderPattern;

public abstract class Builder {
    // 设置产品的不同部分，以获得不同的产品
    public abstract void setPart();

    // 建造产品
    public abstract Product buildProduct();
}
```

```java
package com.ycf.designPattern.BuilderPattern;

public class ConcreteProduct extends Builder{
    private Product product = new Product();

    public void setPart() {
        /**
         * 产品类内的逻辑处理
         */
    }

    public Product buildProduct() {
        return product;
    }
}
```

```java
public class Director {
    private Builder builder = new ConcreteProduct();
    //构建不同的产品
    public Product getAProduct() {
        builder.setPart();
        return builder.buildProduct()
    }
}
```

### 建造者模式的优点

- 封装性

  使用建造者模式可以使客户端不必知道产品内部组成的细节。

- 建造者独立，容易扩展

  相互独立的，对系统的扩展非常有利。

- 便于控制细节风险

  由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。

### 建造者模式的使用场景

相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。

产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。

在对象创建过程中会使用到系统中的一些其他对象，这些对象在产品对象的创建过程中不易得到时，也可以采用建造者模式封装该对象的创建过程。该种场景只能是一个补偿方法，因为一个对象不容易获得，而在设计阶段竟然没有发觉，而要通过创建者模式柔化创建过程，本身已经违反设计的最初目标。建造者模式的注意事项

### 建造者模式的注意事项

建造者模式关注的是零件类型和装配工艺（顺序），这是它与工厂方法模式最大不同的地方，虽然同为创建类模式，但是注重点不同。

## 代理模式

为其他对象提供一种代理以控制对这个对象的访问。

代理模式也叫做委托模式

### 代理模式的优点

- 职责清晰

  真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件事务，附带的结果就是编程简洁清晰。

- 高扩展性

  具体主题角色是随时都会发生变化的，只要它实现了接口，甭管它如何变化，都逃不脱如来佛的手掌（接口），那我们的代理类完全就可以在不做任何修改的情况下使用。

- 智能化



### 代理模式的扩展

### 普通代理

在该模式下，调用者只知代理而不用知道真实的角色是谁，屏蔽了真实角色的变更对高层模块的影响，真实的主题角色想怎么修改就怎么修改，对高层次的模块没有任何的影响，只要你实现了接口所对应的方法，该模式非常适合对扩展性要求较高的场合。当然，在实际的项目中，一般都是通过约定来禁止new一个真实的角色，这也是一个非常好的方案。

注意 普通代理模式的约束问题，尽量通过团队内的编程规范类约束，因为每一个主题类是可被重用的和可维护的，使用技术约束的方式对系统维护是一种非常不利的因素。

### 强制代理

高层模块new了一个真实角色的对象，返回的却是代理角色

###  动态代理

动态代理是在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。

## 原型模式

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

```java
package com.ycf.designPattern.prototypePattern.general;

/**
 * 原型模式通用源码
 */
public class PrototypeClass implements Cloneable {
    @Override
    public PrototypeClass clone() {
        PrototypeClass prototypeClass = null;
        try {
            prototypeClass = (PrototypeClass) super.clone();
        } catch (CloneNotSupportedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return prototypeClass;
    }

}
```

### 原型模式的优点

- 性能优良

  原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。

- 逃避构造函数的约束

  这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的（参见13.4节）。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。

### 原型模式的使用场景

- 资源优化场景

  类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。

- 性能和安全要求的场景

  通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。

- 一个对象多个修改者的场景

  一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。

在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。

### 原型模式的注意事项

- 构造函数不会被执行

  Object类的clone方法的原理是从内存中（具体地说就是堆内存）以二进制流的方式进行拷贝，重新分配一个内存块，那构造函数没有被执行也是非常正常的了。

- 浅拷贝和深拷贝

  Object类提供的方法clone只是拷贝本对象，其对象内部的数组、引用对象等都不拷贝，还是指向原生对象的内部元素地址，这种拷贝就叫做浅拷贝。

  注意 深拷贝和浅拷贝建议不要混合使用，特别是在涉及类的继承时，父类有多个引用的情况就非常复杂，建议的方案是深拷贝和浅拷贝分开实现。

-  clone与final两个冤家

  对象的clone与对象内的final关键字是有冲突的。

  注意 要使用clone方法，类的成员变量上不要增加final关键字。

## 中介者模式

用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。

中介者模式由以下几部分组成

- Mediator 抽象中介者角色

  抽象中介者角色定义统一的接口，用于各同事角色之间的通信。

- Concrete Mediator 具体中介者角色

  具体中介者角色通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。

- Colleague 同事角色

  每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分为两种：

  一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为（Self-Method），与其他的同事类或中介者没有任何的依赖；

  第二种是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method）。

中介者模式适用于多个对象之间紧密耦合的情况，紧密耦合的标准是：在类图中出现了蜘蛛网状结构。在这种情况下一定要考虑使用中介者模式，这有利于把蜘蛛网梳理为星型结构，使原本复杂混乱的关系变得清晰简单。

## 命令模式

将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

- Receive接收者角色

  该角色就是干活的角色，命令传递到这里是应该被执行的

- Command命令角色

  需要执行的所有命令都在这里声明。

- Invoker调用者角色

  接收到命令，并执行命令。

## 责任链模式

使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。

## 策略模式

定义一组算法，将每个算法都封装起来，并且使它们之间可以互换。

策略模式使用的就是面向对象的继承和多态机制

- Context封装角色

  它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。

- Strategy抽象策略角色

  策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。

- ConcreteStrategy具体策略角色

  实现抽象策略中的操作，该类含有具体的算法。

### 策略模式的优点

- 算法可以自由切换

  这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供“可自由切换”的策略。

- 避免使用多重条件判断

  使用策略模式后，可以由其他模块决定采用何种策略，策略家族对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。

- 扩展性良好

  在现有的系统中增加一个策略太容易了，只要实现接口就可以了，其他都不用修改，类似于一个可反复拆卸的插件，这大大地符合了OCP原则。

### 策略模式的缺点

- 策略类数量增多

  每一个策略都是一个类，复用的可能性很小，类数量增多。

- 所有的策略类都需要对外暴露

  上层模块必须知道有哪些策略，然后才能决定使用哪一个策略，这与迪米特法则是相违背的，我只是想使用了一个策略，我凭什么就要了解这个策略呢？那要你的封装类还有什么意义？这是原装策略模式的一个缺点，幸运的是，我们可以使用其他模式来修正这个缺陷，如工厂方法模式、代理模式或享元模式。

###  策略模式的使用场景

- 多个类只有在算法或行为上稍有不同的场景。
- 算法需要自由切换的场景。
- 需要屏蔽算法规则的场景。

### 策略模式的注意事项

如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统维护就会成为一个烫手山芋，谁都不想接。

### 策略模式的扩展

## 适配器模式

将一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

### 适配器模式的优点

- 增加了类的透明性

  访问的Target目标角色，但是具体的实现都委托给了源角色，而这些对高层次模块是透明的，也是它不需要关心的。

- 提高了类的复用度

  源角色在原有的系统中还是可以正常使用，而在目标角色中也可以充当新的演员。

- 灵活性非常好

## 迭代器模式

将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。

## 观察者模式

定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。

## 门面模式

- Facade门面角色

  客户端可以调用这个角色的方法。此角色知晓子系统的所有功能和责任。一般情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去，也就说该角色没有实际的业务逻辑，只是一个委托类。

- subsystem子系统角色

  可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。子系统并不知道门面的存在。对于子系统而言，门面仅仅是另外一个客户端而已。

### 门面模式的优点

- 减少系统的相互依赖
- 提高了灵活性
- 提高安全性



## 备忘录模式

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

### clone方式的备忘录

注意 使用Clone方式的备忘录模式，可以使用在比较简单的场景或者比较单一的场景中，尽量不要与其他的对象产生严重的耦合关系。

### 多状态的备忘录模式

## 解释器模式

## 享元模式

使用共享对象可有效地支持大量的细粒度的对象。

- 内部状态

  内部状态是对象可共享出来的信息，存储在享元对象内部并且不会随环境改变而改变，如我们例子中的id、postAddress等，它们可以作为一个对象的动态附加信息，不必直接储存在具体某个对象中，属于可以共享的部分。

- 外部状态

  外部状态是对象得以依赖的一个标记，是随环境改变而改变的、不可以共享的状态，如我们例子中的考试科目+考试地点复合字符串，它是一批对象的统一标识，是唯一的一个索引值。

  

享元模式角色名称

- Flyweight——抽象享元角色

  它简单地说就是一个产品的抽象类，同时定义出对象的外部状态和内部状态的接口或实现。

- ConcreteFlyweight——具体享元角色

  具体的一个产品类，实现抽象角色定义的业务。该角色中需要注意的是内部状态处理应该与环境无关，不应该出现一个操作改变了内部状态，同时修改了外部状态，这是绝对不允许的。

- unsharedConcreteFlyweight——不可共享的享元角色

  不存在外部状态或者安全要求（如线程安全）不能够使用共享技术的对象，该对象一般不会出现在享元工厂中。

- FlyweightFactory——享元工厂

  职责非常简单，就是构造一个池容器，同时提供从池中获得对象的方法。

享元模式的目的在于运用共享技术，使得一些细粒度的对象可以共享，我们的设计确实也应该这样，多使用细粒度的对象，便于重用或重构

## 桥梁模式

将抽象和实现解耦，使得两者可以独立地变化。

- Abstraction——抽象化角色

  它的主要职责是定义出该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。

- Implementor——实现化角色

  它是接口或者抽象类，定义角色必需的行为和属性。

- RefinedAbstraction——修正抽象化角色

  它引用实现化角色对抽象化角色进行修正。

- ConcreteImplementor——具体实现化角色

  它实现接口或抽象类定义的方法和属性。

### 桥梁模式的优点

- 抽象和实现分离

  这也是桥梁模式的主要特点，它完全是为了解决继承的缺点而提出的设计模式。在该模式下，实现可以不受抽象的约束，不用再绑定在一个固定的抽象层次上。

- 优秀的扩充能力

- 实现细节对客户透明

  由抽象层通过聚合关系完成了封装。

### 桥梁模式的使用场景

- 不希望或不适用使用继承的场景

  例如继承层次过渡、无法更细化设计颗粒等场景，需要考虑使用桥梁模式。

- 接口或抽象类不稳定的场景

  明知道接口不稳定还想通过实现或继承来实现业务需求，那是得不偿失的，也是比较失败的做法。

- 重用性要求较高的场景

  设计的颗粒度越细，则被重用的可能性就越大，而采用继承则受父类的限制，不可能出现太细的颗粒度。



